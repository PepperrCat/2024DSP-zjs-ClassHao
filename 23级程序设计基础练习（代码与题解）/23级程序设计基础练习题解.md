# 23级程序设计基础练习题解

## [1. 判断可逆素数](https://judge.buaa.edu.cn/assignment/programList.jsp?proNum=1&assignID=1378)

### 思路分析

本题在实现思路上没有任何难点，我们只需要实现这两个功能：

1. 给定一个整数，判断其是否为素数；
2. 给定一个整数，返回其颠倒之后的数。

### 具体实现过程

根据上面的思路分析，很容易确定程序主题框架：

~~~c
#include <stdio.h>
#include <math.h>

int isPrime(int num);  // 判断是否为素数
int reverseInt(int num);  // 翻转整数

int main()
{
    int n;
    scanf("%d", &n);
    n = n > 0 ? n : -n;  // 正数化

    if (isPrime(n) && isPrime(reverseInt(n))) printf("yes"); 
    else printf("no");

    return 0;
}
~~~

其中`isPrime`函数用于判断输入的整数是否为素数，是则返回1，否则返回0；`reverseInt`用于将输入的整数颠倒顺序后输出。

值得注意的是，为了方便两函数的实现，我们在主函数中将输入的整数正数化——在判断素数的问题上正负号无关紧要。（一些简单的`if-else`逻辑可以简化为三目运算符）

接下来实现`isPrime`函数。判断素数有很多种算法，这里就采用最朴素的想法（ds这门课的**常规作业**不考虑效率）：从2开始遍历到$sqrt(n)$，如果都没有整除$n$，则其就是素数（一个整数的因子不会大于其平方根）：

~~~c
int isPrime(int num) {  
    for (int i = 2; i < sqrt(num); i++) {
        if (num % i == 0) return 0;
    }
    return 1;  // 全都没有整除，返回1
}
~~~

对于`reverse`函数，只要清楚`n % 10`表示n的个位数，`n /= 10`相当于把n的个位数字去除掉，就问题不大。

~~~c
int reverseInt(int n) {
    int res = 0;  // 记录翻转的结果
    while (n) {
        int tmp = n % 10;  // tmp表示当前数的最后一位
        n /= 10;
        res = res * 10 + tmp;
    }
    return res;
}
~~~

### 参考代码

~~~c
#include <stdio.h>
#include <math.h>

int isPrime(int num);  // 判断是否为素数
int reverseInt(int num);  // 翻转整数

int main()
{
    int n;
    scanf("%d", &n);
    n = n > 0 ? n : -n;  // 正数化

    if (isPrime(n) && isPrime(reverseInt(n))) printf("yes"); 
    else printf("no");

    return 0;
}


int isPrime(int num) {  
    for (int i = 2; i < sqrt(num); i++) {
        if (num % i == 0) return 0;
    }
    return 1;  // 全都没有整除，返回1
}


int reverseInt(int n) {
    int res = 0;  // 记录翻转的结果
    while (n) {
        int tmp = n % 10;  // tmp表示当前数的最后一位
        n /= 10;
        res = res * 10 + tmp;
    }
    return res;
}
~~~

## 2. [矩形相交](https://judge.buaa.edu.cn/assignment/programList.jsp?proNum=2&courseID=25&assignID=1378)

### 思路分析

本题的题面已经给我们提示了要去计算x轴和y轴上的交集。如果两轴上都有交集，显然计算乘积，否则直接输出0即可。

### 具体实现过程

首先在主函数中读入数据，并按照题面提示计算两轴上的交集：

~~~c
// 主函数中
    int Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2;
    scanf("%d%d%d%d%d%d%d%d", &Ax1, &Ay1, &Ax2, &Ay2, &Bx1, &By1, &Bx2, &By2);
    
    int delta_x = min(max(Ax1, Ax2), max(Bx1, Bx2)) - max(min(Ax1, Ax2), min(Bx1, Bx2));  // x轴上交集
    int delta_y = min(max(Ay1, Ay2), max(By1, By2)) - max(min(Ay1, Ay2), min(By1, By2));  // y轴上交集
~~~

其中几个函数可以直接自己写出来（这种非常简单的函数，一行就写完了，不建议用`math.h`中声明好的函数，原因的话，大家可以想想自己是否清楚`asb`和`fabs`函数的区别）：

~~~c
int min(int a, int b) { return a < b ? a : b; }
int max(int a, int b) { return a > b ? a : b; }
int abs(int n) { return n > 0 ? n : 0 - n; }
~~~

然后进行判断输出：

~~~c
// 主函数中
    if (delta_x < 0 || delta_y < 0) printf("%d", 0);
    else printf("%d", delta_x * delta_y);
~~~

### 参考代码

~~~c
#include <stdio.h>

int min(int a, int b) { return a < b ? a : b; }
int max(int a, int b) { return a > b ? a : b; }
int abs(int n) { return n > 0 ? n : 0 - n; }


int main() 
{
    int Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2;
    scanf("%d%d%d%d%d%d%d%d", &Ax1, &Ay1, &Ax2, &Ay2, &Bx1, &By1, &Bx2, &By2);
    
    int delta_x = min(max(Ax1, Ax2), max(Bx1, Bx2)) - max(min(Ax1, Ax2), min(Bx1, Bx2));  // x轴上交集
    int delta_y = min(max(Ay1, Ay2), max(By1, By2)) - max(min(Ay1, Ay2), min(By1, By2));  // y轴上交集

    if (delta_x < 0 || delta_y < 0) printf("%d", 0);
    else printf("%d", delta_x * delta_y);

    return 0;
}
~~~

## [3. 求差集](https://judge.buaa.edu.cn/assignment/programList.jsp?proNum=3&courseID=25&assignID=1378&libCenter=false)

### 思路分析

本题要求最后的输出顺序和A的输入顺序一致，就不用考虑先排序再双指针等想法了，直接暴力求解就可以，我们要做的有这些事情：

1. 读入A的数，并存入数组；
2. 逐个读取B，并在A中寻找是否有相同的数字，如果有，在A中进行标记以区分；
3. 按照顺序打印出A中未被标记的数。

### 具体实现过程

首先初始化集合，并把A读入集合：

~~~c
// 主函数中
    int set[1005] = {0};
    int tmp;
    int n = 0;

    for (n = 0; ; n++) {
        scanf("%d", &tmp);
        if (tmp == -1) break;
        set[n] = tmp;
    }
~~~

然后读入集合B的值，并判断集合中是否已经有该值，如果有，我们将该位置标记为-1（因为题目说读入的都是自然数，不会有-1）：

~~~c
// 主函数中
    while (1) {
        scanf("%d", &tmp);
        if (tmp == -1) break;
        for (int i = 0; i < n; i++) {
            if (set[i] == tmp) set[i] = -1;  // 如果集合中已经存在该数，标记为-1
        }
    }
~~~

接下来对`set`输出即可，注意要判断其值是否被标记过（ == -1）：

~~~c
// 主函数中
    for (int i = 0; i < n; i++) {
        if (set[i] != -1) printf("%d ", set[i]);
    }
~~~

### 参考代码

~~~c
#include <stdio.h>

int main()
{
    int set[1005] = {0};  // 存放结果的集合
    int tmp;
    int n = 0;

    for (n = 0; ; n++) {
        scanf("%d", &tmp);
        if (tmp == -1) break;
        set[n] = tmp;
    }
    
    while (1) {
        scanf("%d", &tmp);
        if (tmp == -1) break;
        for (int i = 0; i < n; i++) {
            if (set[i] == tmp) set[i] = -1;  // 如果集合中已经存在该数，标记为-1
        }
    }

    for (int i = 0; i < n; i++) {
        if (set[i] != -1) printf("%d ", set[i]);
    }

    return 0;
}
~~~

## [4. 矩阵运算](https://judge.buaa.edu.cn/assignment/programList.jsp?proNum=4&courseID=25&assignID=1378&libCenter=false)

### 思路分析

本题在思路上并没有什么障碍，我们只需做如下步骤：

1. 定义一个二维数组，表示矩阵，并把第一个矩阵的值读到数组里；
2. 不断地读入操作符与矩阵，直到读到的操作符为#
3. 每次读矩阵的过程中，根据操作符的不同，更新数组里的值。

需要注意的是：本题中从始至终我们只需要定义一个二维数组，而不用每次读一个矩阵就定义一个，因为我们可以在读的过程中去更新数值（大家在下面的过程中体会）：

### 具体实现过程

首先是初始化数组，并读入第一个矩阵：

~~~c
// 主函数中
    int n;
    char op;  // 操作符
    int matrix[10][10] = {{0}};  // 矩阵  

    scanf("%d", &n);

    for (int i = 0; i < n; i++) {  // 读矩阵
        for (int j = 0; j < n; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }
~~~

然后我们要循环读入一个操作符，直到读入的操作符为#。

在循环体中，我们继续读取矩阵的每一个元素——在读入之后可以立即更新数组的值（如果有矩阵乘法，那这样就行不通了，那样我们只能把该矩阵整体读到另一个数组后再处理）：

~~~c
// 主函数中
    while (scanf(" %c", &op) != EOF && op != '#') {  // 注意读字符前吞掉空格
        int tmp;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                scanf("%d", &tmp);
                // 直接根据操作符更新数组
                if (op == '+') matrix[i][j] += tmp;  
                else matrix[i][j] -= tmp;
            }
        }
    }
~~~

最后对数组进行输出即可：

~~~c
// 主函数中
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%5d", matrix[i][j]);
        }
        printf("\n");
    }
~~~

### 参考代码

~~~c
#include <stdio.h>

int main()
{
    int n;
    char op;  // 操作符
    int matrix[10][10] = {{0}};  // 矩阵  

    scanf("%d", &n);

    for (int i = 0; i < n; i++) {  // 读矩阵
        for (int j = 0; j < n; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }

    while (scanf(" %c", &op) != EOF && op != '#') {  // 注意读字符前吞掉空格
        int tmp;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                scanf("%d", &tmp);
                // 直接根据操作符更新数组
                if (op == '+') matrix[i][j] += tmp;  
                else matrix[i][j] -= tmp;
            }
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%5d", matrix[i][j]);
        }
        printf("\n");
    }

    return 0;
}
~~~

## [5. 文件拷贝](https://judge.buaa.edu.cn/assignment/programList.jsp?proNum=5&courseID=25&assignID=1378&libCenter=false)

### 思路分析——双指针法

本题披上了文件操作的外套，如果我们去掉这层外套，可以把题面改写如下：给定一个字符串，将其中连续的多个空白字符替换为一个空格，并输出新的字符串。

这道题的想法很简单，却十分考验大家对代码的流程控制，以及算法功底，相信很多同学写着写着就发现代码写得“又长又烂”，逻辑十分混乱。

我这里介绍一种双指针的处理思路，它的时间复杂度是O(n)，比大家的暴力解法要快很多，逻辑也更清晰。

如果开头的字符不是空白字符（先考虑这种情况，到时候一行代码特判一下空白字符开头的情况就可以），我们可以把输入的字符串看成这样（“若干”的意思是大于等于0）：

第0个非空白字符 若干空白字符 第一个非空白字符 若干空白字符 。。。。。。

可以发现，**除了最开始（第0个）非空白字符外，其他的空白字符一定出现在非空白字符之前**。这里假设我们要处理的字符串变量为`buf`，我们的目的是去除掉`buf`中连续的空白字符。

我们可以定义两个整数`slow`和`fast`，代表遍历的字符数组的下标（也成为快慢“指针”——指向数组位置的针，不是真的指针变量），初始化时都为0.

接下来让`fast`指针遍历`buf`，当该位置上的字符是空白字符时，我们不去管它，只有当遇到了非空白字符时，我们才进行处理——给`slow`所指向的位置添加一个空格，然后`slow`向后移动一位，接下来`slow`和`fast`一起向前移动，并给`slow`所指向的位置赋值，直到遇到了下一个空白字符。最后重置一下`buf`的长度即可。

同时，由于字符串开头还有可能是空白字符，所以需要特判一下。

大家看这份文字版的题解可能觉得难以理解，这里我先给出完整代码：

### 参考代码

~~~c
#include <stdio.h>
#include <string.h>

int main()
{
    char buf[1024] = {0};
    FILE *in = fopen("fcopy.in", "r");
    FILE *out = fopen("fcopy.out", "w");

    while (fgets(buf, sizeof(buf), in) != NULL) {  // 一行一行读文件
        int fast = 0, slow = 0;  // 用双指针法去除空格
        int len = strlen(buf);
        for (fast = 0; fast < len; fast++) {  // 快指针遍历数组
            if (buf[fast] != ' ' && buf[fast] != '\t') {  // 遇到非空白字符再处理
                if (!(slow == 0 && fast == 0)) buf[slow++] = ' ';  // 特判文件开头就是空格的情况
                while (fast < len && buf[fast] != ' ' && buf[fast] != '\t') {  // 注意此处的约束条件
                    buf[slow++] = buf[fast++];
                }
            }
            if (fast == len - 1 && buf[fast] == ' ' && buf[fast] != '\t') buf[slow++] = ' ';  // 特判文件尾是空格
        }
        buf[slow] = '\0';  // 重置字符串长度
        fprintf(out, "%s", buf);
    }

    return 0;
}
~~~

其实这个想法最难以理解的地方是**只有当我们遇到非空白字符时才处理**，也就是每次都是读到了连续空白字符的最后一个才处理——可能大家常规的想法是读到连续空白字符的第一个时就处理。

其次，这个算法的所有操作都是在`buf`这一个字符串上操作的，我们并没有额外开辟新的存储空间。

有的同学可能有疑问：这不是两层循环吗？但其实数组的每个元素只会被遍历到1次或2次，所以时间复杂阿德是O(n)。

无论如何，文字版的讲解总会显得不那么直观，如果大家有问题，不妨自己模拟一下操作流程，或者和同学或助教一起讨论一下。同时，建议大家理解思路之后自己再手动敲一遍这道题——这是很考验大家流程控制的一个算法。

### 双指针举例

ds课程中的常规作业不对代码效率做要求，所以大家如果觉得双指针太难理解，也可以适当缓一缓。

双指针是在线性表（数组，还有后面学到的链表等）上非常实用的一种处理思路，大家上网上搜算法题时也能搜到很多双指针的妙用，这里我举一个非常简单也很经典的例子：

给一单链表（链表可以理解成数组，但是其中的每一个元素只能通过它的前一个元素去找到，比如要找到下标为3的结点，只能从下标为0的头结点开始，先找到下标为1的结点，再找到下标为2的结点，再找到3的结点），在不求出链表长度的情况下（显式或隐式都不可以），返回其倒数第n个结点，如没有，返回NULL。

正常的想法肯定是从头开始遍历到尾，记录出链表长度，然后再从头开始遍历相应的次数就可以，但是题目规定了不可以求出长度。

双指针解法如下：

1. 定义快慢指针`fast = 头结点; slow = 头结点`；
2. 先让`fast`向后移动n次，如果在这过程中超过了链表的最后一个结点（最后一个结点的下一个是NULL），就返回NULL；
3. 然后两指针一起向后移动，直到`fast`到达链表末尾，此时`slow`所指向的结点就是倒数第n个。

这个例子大家可以在学完链表后再来看一看，如果大家对双指针有兴趣，也可以自行去网上搜索相应题目。
