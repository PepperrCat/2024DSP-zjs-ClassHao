# 猪脚说第三期

## 23级程序设计基础训练题解

### [9. 最长升序子串](https://judge.buaa.edu.cn/assignment/programList.jsp?proNum=9&assignID=1378)

#### 动态规划原理

本题是一道比较经典的题目，这里介绍一种叫做“动态规划”的算法。但正如题面所说，本题作为选做题其实并不需要大家掌握这种算法的设计技巧，这也不是本门课程的重点，这里写出题解供学有余力的同学参考。

其实动态规划的思想在大家小学学的一些稍有难度的数学题里就有体现，比如下题：

有一个4X3的网格，一个人从左下的位置出发，问到达其他块分别最短需要多少步（假设只能横竖移动）：

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
| 0    |      |      |

大家在高中阶段解决这道题会用排列组合相关知识，但是小学时，我们学过一种更加“无脑”的操作：现在假设从左下的起点开始，标记为0（意为最短需要0步）。下一步可以到达的位置显然最短需要的步数就是1：

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
| 1    |      |      |
| 0    | 1    |      |

而接下来，我们可以根据已经“到达”的点继续迭代标记：

|      |      |      |
| ---- | ---- | ---- |
| 2    |      |      |
| 1    | 2    |      |
| 0    | 1    | 2    |

接下来同理：

| 3    |      |      |
| ---- | ---- | ---- |
| 2    | 3    |      |
| 1    | 2    | 3    |
| 0    | 1    | 2    |

以此类推，接下来的两步我就不展示了。

这种方法的好处在于：即使所给的网格并不规整（比如本题只有横竖交叉），我们依然可以根据“已经到达的地方”去不断扩展“未知的领域”。大家也能很容易想到：加入当前的位置已经被标记过（也就是到达过），那么当再有一个点到达此处时，我们要比较出已标记和新的路径的长度，取其小的值——这也是“规划”一词的含义。

大家可以在本题中继续领略这一算法的思想。

#### 思路分析

经过上面的铺垫，可以依照相同的思想将本题的思路归纳如下：

1. 开一个`int``型数组，用于记录以此位置为重点的子串中最长的长度；
2. 遍历输入的字符串，并判断在之前走过的路径中可以到达此点的路径最短值（如果之前的都到不了，则记为1——这一点也可以放在第一步数组的初始化时——我后面的代码就会这么去写）——可以想象的到，这就是动态地去更新的过程。
3. 为了记录数组中最大值，应设置一个变量也动态地去记录。

本题的代码十分简单，这里直接给出代码，如果大家对此不是很理解，可以按照上面的步骤自己手动模拟一下。

#### 参考代码

~~~c
#include <stdio.h>

int max(int a, int b) { return a > b ? a : b; }

int main()
{
    char s[10005] = {0};   
    int dp[10005] = {1}; 
    int res = 0;  // 记录结果

    scanf("%s", s);
    for (int i = 1; s[i]; i++) {
        for (int j = 0; j < i; j++) {
            if (s[i] >= s[j]) dp[i] = max(dp[i], dp[j] + 1);
        }
        if (dp[i] > res) res= dp[i]; // 取长的子序列
    }

    printf("%d\n", res);
    return 0;   
}
~~~

#### 扩展思考

大家可以思考一下，如果本题要求找出最长的**连续**的子串，又有什么思路呢？大家可以去搜索一下“**滑动窗口**”算法，看看会不会有启发，欢迎大家将自己的想法分享到群里和大家一起探讨。（第11题就是考察滑动窗口算法）

### [10. 合并字符串](https://judge.buaa.edu.cn/assignment/programList.jsp?proNum=10&courseID=25&assignID=1378&libCenter=false)

本题和第六题的双指针思路简直没有任何区别——本题更是直接告诉了大家两串都是有序的，建议大家自己写一遍，然后对照着参考代码看看代码的简洁性与规范性：

#### 参考代码

~~~c
#include <stdio.h>
#include <string.h>

void str_bin(char str1[], char str2[]);


int main()
{
    char str1[1024] = {0};
    char str2[1024] = {0};
    scanf("%s%s", str1, str2);
    str_bin(str1, str2);
    printf("%s", str1);

    return 0;
}


void str_bin(char str1[], char str2[]) {
    char tmp[1024] = {0};  // 记录结果的数组
    int i = 0, j = 0;  // 双指针
    while (str1[i] && str2[j])  // 双指针遍历移动
        tmp[i + j] = str1[i] < str2[j] ? str1[i++] : str2[j++];    
    
    // 将没有到头的那一个串的剩余部分输出
    if (str1[i])  while (str1[i]) tmp[i + j] = str1[i++];
    else while (str2[j]) tmp[i + j] = str2[j++];
    strcpy(str1, tmp);
}
~~~

### [11. 连续正整数的和](https://judge.buaa.edu.cn/assignment/programList.jsp?proNum=11&courseID=25&assignID=1378&libCenter=false)

本题就用到了我在第10题留下的悬念——滑动窗口算法。

#### 思路分析

我们可以想象正整数依次排列开来：1 2 3 4 5 ...

我们的目的是寻找连续的正整数，所以其实只要确定两个数——即开始的数和结尾的数——就可以确定这样一个连续的区间。

所以不难想象，可以用两层`for`循环，第一层遍历代表连续区间的末尾，第二层代表区间的起始位置，判断当前区间内的数值是否符合要求，如果有符合要求的数，我们就记录下来，并比较出最长的那一种情况，最后输出即可。

但是这样两层`for`循环显然时间复杂度是`O(n^2)`——这种算法不难实现，建议大家自己敲一遍练练手。

其实利用滑动窗口，我们可以将此算法的时间复杂度优化掉一层，变成`O(n)`。

具体如何实现呢，大家可以想一下：假如当前遍历到的区间是[4, 7]，目标是22，显然得到了目标，而当我们将区间的末尾移动至8时，其实最理想的情况下，如果有满足条件的区间的话，区间开头也要从5开始——这一点是不是有点像一个窗口一直在滑动？

所以，每当我们更新了区间尾时，没有必要从头开始遍历区间开头，只要从上一次区间的头开始继续往后遍历即可。

同时，区间尾的移动虽然是一个一个数移动的，但是头部却不然，因为尾部的数一定比头部的数大很多——我们只要一直维持着区间内部的和小于等于目标值即可（遇到目标值就记录）。

所以，我们只需遍历一层——这一层是代表窗口区间的末尾。

同时，为了记录结果（起始位置，终止位置，窗口长度），我们不妨设置一个结构体（其实没必要，就是想让大家练习一下结构体）。

#### 具体实现过程

声明结果类型结构体：

~~~c
typedef struct {
    int i;
    int j;
    int len;
} result;
~~~

其中`i`，`j`，`len`分别代表窗口的起始位置，终止位置与长度。

然后在主函数中读入`n`，并定义结果变量，并进行初始化：

~~~c
// 主函数中
    // i代表窗口头，j代表窗口尾
    int i = 1, j = 1;
    int sum = 0;  // 当前窗口内的和
    result res; res.len = 0;
~~~

然后遍历窗口尾，并且每次都移动窗口头，始终位置窗口内的和小于等于目标值：

~~~c
// 主函数中
    for (j = 1; j < n; j++) {
        sum += j;
        while (sum > n) sum -= (i++);
        if (sum == n && j - i + 1 > res.len) {  // 更新res
            res.i = i;
            res.j = j;
            res.len = j - i + 1;
        }
    }
~~~

大家可能会想这不是也是两层循环吗，但其实如果单独看每一个数的话，最多被遍历到了两次，所以其实复杂度还是`O(n)`。

最后判断有没有结果(`res.len == 0 ?`)，并进行输出：

~~~c
// 主函数中
    if (res.len == 0) printf("No Answer");
    else {
        printf("%d=", n);
        for (i = res.i; i <= res.j; i++) {
            printf("%d", i);
            if (i != res.j) printf("+");
        }
    }
~~~

####  

完整代码

~~~c
#include <stdio.h>
#include <math.h>

typedef struct {
    int i;
    int j;
    int len;
} result;

int main()
{
    int n;
    scanf("%d", &n);
  
    // i代表窗口头，j代表窗口尾
    int i = 1, j = 1;
    int sum = 0;  // 当前窗口内的和
    result res; res.len = 0;

    for (j = 1; j < n; j++) {
        sum += j;
        while (sum > n) sum -= (i++);
        if (sum == n && j - i + 1 > res.len) {  // 更新res
            res.i = i;
            res.j = j;
            res.len = j - i + 1;
        }
    }

    if (res.len == 0) printf("No Answer");
    else {
        printf("%d=", n);
        for (i = res.i; i <= res.j; i++) {
            printf("%d", i);
            if (i != res.j) printf("+");
        }
    }
    
    return 0;
}

~~~

#### 扩展——如何迅速判断有没有解

大家可能发现了，所有的奇数都可以分解为连续的整数和（至少2个，除以二和除以二加一就行），但是偶数呢？

如果大家注意力惊人，会发现2,4,8,16...这些无法分解，其他都可以——但这是数学而不是编程，所以我不做证明，只是强调一点：如果用位运算去判断2,4,8,16...这些2的整数次幂呢？

其实只要判断`n & (n - 1)  == 0 ?`即可，所以本题也可以写成如下版本：

~~~c
#include <stdio.h>
#include <math.h>

typedef struct {
    int i;
    int j;
    int len;
} result;

int main()
{
    int n;
    scanf("%d", &n);

    if ((n & (n - 1)) == 0) printf("No Answer");
    else {
        // i代表窗口头，j代表窗口尾
        int i = 1, j = 1;
        int sum = 0;  // 当前窗口内的和
        result res; res.len = 0;
        for (j = 1; j < n; j++) {
            sum += j;
            while (sum > n) sum -= (i++);
            if (sum == n && j - i + 1 > res.len) {  // 更新res
                res.i = i;
                res.j = j;
                res.len = j - i + 1;
            }
        }
        printf("%d=", n);
        for (i = res.i; i <= res.j; i++) {
            printf("%d", i);
            if (i != res.j) printf("+");
        }
    }

    return 0;
}

~~~

## 本周问题汇总

### 操作字符串后添加'\0'

我们都知道在C语言中字符串就是以`'\0'`为终点的字符数组，那么理论上当我们修改了某个字符串的内容时，**必须**要再把其末尾相应位置置为`'\0'`——这一点非常重要，无论你有多么充分的理由去证明在当前情况下省略这一步也可以，都建议大家还是进行一下这个操作。本周答疑过程中，大家往往就是有自己的理由不去做这一点，导致出现离奇的错误。

下面我举个例子模拟这个错误：

~~~c
char s[10] = "wangliang";
~~~

这行代码定义了一个字符串并进行了初始化，字符串的结构应该是这样的：

| w    | a    | n    | g    | l    | i    | a    | n    | g    | \0   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

那么当我在程序中某个地方进行了这样的操作后：

~~~c
char tmp[] = "liping";
strcpy(s, tmp);
~~~

实际上现在`s`的结构是这样的：

| l    | i    | p    | i    | n    | g    | \0   | n    | g    | \0   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

我们之所以认为这个字符串是`"liping"`，不是因为这个数组里只有这些字符，而是因为第一个`\0`出现在这些字符之后——数组后面的东西都无关紧要了。

那么当我想在`s`后面追加一个字符的时候：

~~~c
s[strlen(s)] = "_";
~~~

其结构就是这样的：

| l    | i    | p    | i    | n    | g    | _    | n    | g    | \0   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

可见当前字符串并不是我们想要的`"liping_"`，而是`liping_ng`。

